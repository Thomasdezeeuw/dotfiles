#
# # Environment variables
#

# Add user bin to path.
PATH="$HOME/bin:$PATH"

# Vim as the editor.
export EDITOR="vim"
export VISUAL="$EDITOR"
export GIT_EDITOR="$EDITOR"

# Boring language stuff.
export LANG="en_US.UTF-8"
export LC_ALL="en_US.UTF-8"

# Pretty colors, yey!
export CLICOLOR=1

# Don't listen to ctrl-d, I hit that way too often.
export IGNOREEOF=2

# Determine what shell we're using.
if [ -n "$BASH_VERSION" ] ; then
	shell="bash"
elif [ -n "$ZSH_VERSION" ] ; then
	shell="zsh"
else
	echo "Unknown shell, only supports bash or zsh" >&2
	exit 1
fi

# Utility function to determine if a binary is available.
has_bin() {
	type "$1" > /dev/null 2> /dev/null
}

#
# # Profile extensions
#

if [ $shell = "bash" ]; then
	PROFILE_ROOT=$(dirname ${BASH_SOURCE[0]})
elif [ $shell = "zsh" ]; then
	PROFILE_ROOT=$(dirname ${(%):-%N})
fi

# Load programming language specific profile extensions.
for file in $PROFILE_ROOT/lang/*; do
	source "$file"
done

# Load OS specific profile extensions.
OS=$(uname -s | tr "[:upper:]" "[:lower:]")
source "$PROFILE_ROOT/os/$OS"

#
# Setup SSH
#

# Ensure that ssh-agent is running.
if [ -z ${SSH_AUTH_SOCK+x} ]; then
	eval `ssh-agent -s` > /dev/null
fi

# Ensure identities are added to the agent.
if ! ssh-add -L > /dev/null; then
	echo "Adding identities to ssh-agent"
	ssh-add
fi

#
# # Commands and aliases
#

alias tmpdir='cd $(mktemp -d)' # Create a temporary directory and cd into it.
alias q="exit"                 # Quick exit.
has_bin exa && alias ls="exa"  # I prefer exa.
has_bin rg && alias grep="rg"  # THA SPEED!
alias la="ls -a"               # Show me all the things!
alias l="ls -l"                # Quick list.
alias vim="vim -p"             # Open each file in a separate tab.
alias e="vim"                  # I got super lazy.
alias scp=sftp                 # Use sftp instead.
# Use different notes directory.
alias notes="NOTES_ROOT=~/src/notes/weekly notes"

# Overwrites the `rm` command, but only in the shell not in scripts.
rm() {
	echo "Did you mean 'trash'?"
	return 1
}

#
# # Prompt utils.
#

# Exit status is 0 if inside a git repo, 1 otherwise.
in_git_repo() {
	git rev-parse --is-inside-work-tree > /dev/null 2> /dev/null
}

# Returns 1 if the branch is dirty, 0 otherwise.
#
# Note: only works if in a repo.
is_tree_clean() {
	git diff --quiet --ignore-submodules HEAD 2> /dev/null
}

# The current git branch.
git_branch() {
	git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1 /'
}

# Get a clean directory for the prompt.
# When in a git repo this removes everything before the start of the root of the
# repo, also replaces the home directory with "~".
prompt_dir() {
	# Determine if we're in a git repo. If so we get the full path to the repo,
	# or we'll have an empty string.
	local GIT_DIR=$(git rev-parse --show-toplevel 2> /dev/null)
	# Next we determine what part of the path we can remove, e.g. given a
	# `GIT_DIR` of "~/src/repo_root" this will be "~/src".
	local GIT_TRIM_DIR=$(printf "$GIT_DIR" | rev | cut -d'/' -f2- | rev)

	# If we're in a git repo we'll remove the entire path up to the repo root
	# directory, e.g. "~/src/repo_root/src" becomes "repo_root/src".
	local PWD=$(pwd -P)
	local DIR=${PWD#${GIT_TRIM_DIR}}

	# Replace the home directory path with "~/".
	local DIR=${DIR/$HOME/\~\/}
	# Remove the last "/".
	local DIR=${DIR/\//}

	printf "$DIR"
}
